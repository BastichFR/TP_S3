<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
        <meta charset="utf-8">
        <meta name="author" content="David Bouchet">
        <title>Pointers</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <style>

          body {
              background-color: #FFFFFF;
          }

code[class*="language-"],
pre[class*="language-"] {
   color: #ffffff;
   background: none;
   text-shadow: 0 1px rgba(0, 0, 0, 0.3);
   font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
   text-align: left;
   white-space: pre;
   word-spacing: normal;
   word-break: normal;
   word-wrap: normal;
   line-height: 1.5;

   -moz-tab-size: 4;
   -o-tab-size: 4;
   tab-size: 4;

   -webkit-hyphens: none;
   -moz-hyphens: none;
   -ms-hyphens: none;
   hyphens: none;
}

/* Code blocks */
pre[class*="language-"] {
   padding: 0.5em;
   margin: 0em 0;
   overflow: auto;
   border-radius: 0.3em;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
   background: #272822;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
   padding: .1em;
   border-radius: .3em;
   white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
   color: slategray;
}

.token.punctuation {
   color: #f8f8f2;
}

.namespace {
   opacity: .7;
}

.token.property,
.token.tag,
.token.constant,
.token.symbol,
.token.deleted {
   color: #f92672;
}

.token.boolean,
.token.number {
   color: #ae81ff;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
   color: #a6e22e;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string,
.token.variable {
   color: #f8f8f2;
}

.token.atrule,
.token.attr-value,
.token.function {
   color: #e6db74;
}

.token.keyword {
   color: #66d9ef;
}

.token.regex,
.token.important {
   color: #fd971f;
}

.token.important,
.token.bold {
   font-weight: bold;
}
.token.italic {
   font-style: italic;
}

.token.entity {
   cursor: help;
}

pre.line-numbers {
   position: relative;
   padding-left: 3.8em;
   counter-reset: linenumber;
}

pre.line-numbers > code {
   position: relative;
   white-space: inherit;
}

.line-numbers .line-numbers-rows {
   position: absolute;
   pointer-events: none;
   top: 0;
   font-size: 100%;
   left: -3.8em;
   width: 3em; /* works for line-numbers below 1000 lines */
   letter-spacing: -1px;
   border-right: 1px solid #999;

   -webkit-user-select: none;
   -moz-user-select: none;
   -ms-user-select: none;
   user-select: none;

}

   .line-numbers-rows > span {
       pointer-events: none;
       display: block;
       counter-increment: linenumber;
   }

       .line-numbers-rows > span:before {
           content: counter(linenumber);
           color: #999;
           display: block;
           padding-right: 0.8em;
           text-align: right;
       }

/* Matrices */

table.matrix
{
  margin: auto;
  border: solid 2px;
  border-collapse: collapse;
}

table.matrix td
{
  border: solid 1px;
  padding: 0.7em;
}

p.two_indices_to_one
{
  text-align: center;
  margin-bottom: 2rem;
}

p.img img
{
width: auto;
margin-left: auto;
margin-right: auto;
}

p.img
{
  text-align: center;
}

@media (max-width: 900px)
{
  p.img img
  {
   max-width: 90%;
     margin-left: auto;
   margin-right: auto;
  }
}

/* Moving Chessmen */

table.chessboard
{
  border-collapse: collapse;
  text-align: center;
  margin: auto;
}

table.chessboard td
{
  border: solid black 1px;
  width: 1.5rem;
  height: 1.5rem;
}
table.chessboard th
{
  padding: 0rem 0.5rem;
}

table.chessboard tr:nth-child(even) td:nth-child(even),
table.chessboard tr:nth-child(odd) td:nth-child(odd)
{
  background-color: #ffcf9f;
}

table.chessboard tr:nth-child(even) td:nth-child(odd),
table.chessboard tr:nth-child(odd) td:nth-child(even)
{
  background-color: #d28c45;
}

body
{
font-family: sans-serif;

display: flex;
flex-direction: column;

margin: 0px;


}

h2.exercise
{
counter-reset: q;
}

p.question:before
{
counter-increment: q;
content: counter(q) ". ";
font-weight: bold;
}

h3.question:before
{
counter-increment: q;
content: counter(q) ". ";
}

span.date
{
color: #006786;
}

details
{
  transition: height 250ms ease;
  overflow: hidden;
}

details:not([open])
{
  height: 1.5em;
}

details[open]
{
  height: 5em;
}

summary
{
color: green;
}

summary:hover
{
text-decoration: underline;
cursor: help;
}

header
{
position: fixed;
width: 100%;
margin: auto;
background: rgba(0, 0, 0, 0.6);
color: white;
top: Oem;
transition: top 250ms;
}

header div
{
display: flex;
justify-content: space-between;
padding: 0.2rem 2rem;
font-weight: bold;
}

header a:link,
header a:visited
{
color: white;
text-decoration: none;
}

nav
{
margin: 0rem auto 0rem auto;
width: 900px;
box-sizing: border-box;
border-right: dashed 1px black;
padding-right: 1rem;
border-left: dashed 1px black;
padding-left: 1rem;
padding-top: 1rem;
}


nav h2,
nav h3,
nav h4
{
background: none;
border: none;
margin: 0px;
padding: 0px;
font-size: 1.1rem;
text-shadow: none;
font-weight: normal;
line-height: 1.6;
}

nav h2
{
font-weight: bold;
font-size: 1.3rem;
margin-top: 0.5rem;
}

nav h3
{
margin-left: 2rem;
font-size: 1.1rem;
}

nav h4
{
margin-left: 4rem;
}

nav h2 a:link,
nav h3 a:link,
nav h4 a:link,
nav h2 a:visited,
nav h3 a:visited,
nav h4 a:visited
{
color: #006786;
text-decoration: none;
}

nav h2 a:hover,
nav h3 a:hover,
nav h4 a:hover
{
color: white;
background-color: #006786;
}


.title
{
display: flex;
flex-direction: column;
background-color: white;
justify-content: space-between;
}

.practical_number
{
margin: 0px;
text-align: left;
padding-left: 2em;
background-color: black;
color: white;
font-size: 3em;
width: 30rem;
border-top: solid 0.1rem black;
position: relative;
top: 2rem;
border-radius: 0px 8px 0px 0px;
}

h1
{
background-color: #2F97B6;
margin-top: 0px;
color: white;
text-shadow: 2px 2px 2px black;
/*border-bottom: solid 1px black;*/
border-top: solid 0.5rem black;
text-align: center;
font-size: 3rem;
margin: 0px;
width: 100%;
line-height: 1.2;
padding-top: 3rem;
padding-bottom: 1rem;
}

.bonus
{
color: #d00000;
font-weight: bold;
}

mark
{
color: #d00000;
background: none;
/*font-weight: bold;*/
}

code.s
{
font-family: monospace;
color: darkgoldenrod;
font-weight: bold;
}

mark code.s
{
color: inherit;
}


strong
{
font-style: italic;
}

p + ul
{
margin-top: -1em;
}

h2
{
color: #0087B6;
/*color: #e03043;*/
text-shadow: 1px 1px 1px black;
font-size: 2.2rem;
border-bottom: solid 0.2rem #0087B6;
padding-bottom: 1.5rem;
margin-top: 4rem;
line-height: 1.2;
font-weight: normal;
}

h3
{
background-color: #2F97B6;
color: white;
padding: 0.3rem 1rem;
font-weight: normal;
border-left: solid 0.5rem black;
font-size: 1.3rem;
}

h4
{
color: #0087B6;
font-size: 1.3rem;
}

main
{
box-sizing: border-box;
width: 900px;
margin: auto;
font-size: 1.1rem;
line-height: 1.6;
text-align: justify;
border-right: dashed 1px black;
padding-right: 1rem;
border-left: dashed 1px black;
padding-left: 1rem;
}

a:link, a:visited
{
color: #ff7000;
/*color: darkorange;*/
text-decoration: underline;
}

a:hover
{
text-decoration: underline;
background-color: #ff7000;
color: white;
}

div.filename
{
border: solid 1px gray;
margin-left: 3.3rem;
color: white;
background-color: #272822;
padding: 0.2rem 1.2rem;
border-radius: 0.7rem 0.7rem 0px 0px;
font-family: monospace;
font-size: 1rem;
font-weight: bold;
text-align: center;
width: 12rem;
}

pre + div.filename
{
margin-top: 2rem;
}

table.ls_f,
table.ls_owner_group_other
{
border-collapse: collapse;
margin: 2em auto;
border: solid 2px #004076;
}

table.ls_f th,
table.ls_owner_group_other th
{
padding: 0.2em 1em;
background-color: #2F97B6;
color: white;
border: solid 1px #004076;
}

table.ls_f td,
table.ls_owner_group_other td
{
border: solid 1px #004076;
padding: 0.2em 1em;
}

table.ls_f tr th:first-child,
table.ls_f tr td:first-child,
table.ls_owner_group_other tr th,
table.ls_owner_group_other tr td
{
text-align: center;
}

table tr th.description,
table tr td.description
{
text-align: left;
}


kbd
{
font-size: 1.1rem;
border-style: solid;
border-width: 2px;
padding: 2px 7px 3px 7px;
margin-left: 1px;
margin-right: 4px;
border-radius: 5px;
background-color: #f0f0f0;
box-shadow: 1px 1px 3px black;
}

img
{
width: 60%;
margin-left: 20%;
margin-right: 20%;
}

img.screenshot
{
width: 90%;
margin-left: 5%;
margin-right: 5%;
  box-shadow: 3px 3px 8px black;
}

body > footer
{
display: flex;
justify-content: center;
background: #2F97B6;
color: white;
border-top: solid black 1px;
}

body > footer span
{
margin: 0rem 2rem 0rem 2rem;
}

body > footer a:visited,
body > footer a:link
{
color: white;
text-decoration: none;
}

body > footer a:hover
{
background: none;
text-decoration: underline;
}

dt
{
font-weight: bold;
}

dd
{
margin-bottom: 1rem;
}


@media (max-width: 900px)
{
  body
  {
      width: auto;
      margin: 0px;
      padding: 0px;
      box-sizing: border-box;
  }
header div
{
  padding: 0rem 1rem;
  font-weight: normal;
}

nav
{
  width: 100%;
}


  main
  {
      width: auto;
      margin-left: 0px;
      margin-right: 0px;
      text-align: left;
  }

  .practical_number
  {
      margin: 0px;
      text-align: center;
      padding-left: 0em;
      background-color: black;
      color: white;
      font-size: 2.5em;
      width: 100%;
      border-top: solid 0.1rem black;
      position: relative;
      top: 2rem;
      border-radius: 0px;
  }

h1
{
  font-size: 2.5em;
}

img
{
  width: 90%;
  margin-left: 5%;
  margin-right: 5%;
}

}

blockquote
{
border: 1px dotted black;
padding: 0.7rem 1.2rem;
background-color: #eee;
box-shadow: 1px 1px 1px black;
font-style: italic;
}
  </style>
  <script>
      /* PrismJS 1.14.0
      http://prismjs.com/download.html#themes=prism-okaidia&languages=clike+c+bash+makefile&plugins=line-numbers+normalize-whitespace */
      var _self = (typeof window !== 'undefined')
          ? window   // if in browser
          : (
              (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)
              ? self // if in worker
              : {}   // if in node js
          );
      
      /**
       * Prism: Lightweight, robust, elegant syntax highlighting
       * MIT license http://www.opensource.org/licenses/mit-license.php/
       * @author Lea Verou http://lea.verou.me
       */
      
      var Prism = (function(){
      
      // Private helper vars
      var lang = /\blang(?:uage)?-([\w-]+)\b/i;
      var uniqueId = 0;
      
      var _ = _self.Prism = {
          manual: _self.Prism && _self.Prism.manual,
          disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,
          util: {
              encode: function (tokens) {
                  if (tokens instanceof Token) {
                      return new Token(tokens.type, _.util.encode(tokens.content), tokens.alias);
                  } else if (_.util.type(tokens) === 'Array') {
                      return tokens.map(_.util.encode);
                  } else {
                      return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
                  }
              },
      
              type: function (o) {
                  return Object.prototype.toString.call(o).match(/\[object (\w+)\]/)[1];
              },
      
              objId: function (obj) {
                  if (!obj['__id']) {
                      Object.defineProperty(obj, '__id', { value: ++uniqueId });
                  }
                  return obj['__id'];
              },
      
              // Deep clone a language definition (e.g. to extend it)
              clone: function (o, visited) {
                  var type = _.util.type(o);
                  visited = visited || {};
      
                  switch (type) {
                      case 'Object':
                          if (visited[_.util.objId(o)]) {
                              return visited[_.util.objId(o)];
                          }
                          var clone = {};
                          visited[_.util.objId(o)] = clone;
      
                          for (var key in o) {
                              if (o.hasOwnProperty(key)) {
                                  clone[key] = _.util.clone(o[key], visited);
                              }
                          }
      
                          return clone;
      
                      case 'Array':
                          if (visited[_.util.objId(o)]) {
                              return visited[_.util.objId(o)];
                          }
                          var clone = [];
                          visited[_.util.objId(o)] = clone;
      
                          o.forEach(function (v, i) {
                              clone[i] = _.util.clone(v, visited);
                          });
      
                          return clone;
                  }
      
                  return o;
              }
          },
      
          languages: {
              extend: function (id, redef) {
                  var lang = _.util.clone(_.languages[id]);
      
                  for (var key in redef) {
                      lang[key] = redef[key];
                  }
      
                  return lang;
              },
      
              /**
               * Insert a token before another token in a language literal
               * As this needs to recreate the object (we cannot actually insert before keys in object literals),
               * we cannot just provide an object, we need anobject and a key.
               * @param inside The key (or language id) of the parent
               * @param before The key to insert before. If not provided, the function appends instead.
               * @param insert Object with the key/value pairs to insert
               * @param root The object that contains `inside`. If equal to Prism.languages, it can be omitted.
               */
              insertBefore: function (inside, before, insert, root) {
                  root = root || _.languages;
                  var grammar = root[inside];
      
                  if (arguments.length == 2) {
                      insert = arguments[1];
      
                      for (var newToken in insert) {
                          if (insert.hasOwnProperty(newToken)) {
                              grammar[newToken] = insert[newToken];
                          }
                      }
      
                      return grammar;
                  }
      
                  var ret = {};
      
                  for (var token in grammar) {
      
                      if (grammar.hasOwnProperty(token)) {
      
                          if (token == before) {
      
                              for (var newToken in insert) {
      
                                  if (insert.hasOwnProperty(newToken)) {
                                      ret[newToken] = insert[newToken];
                                  }
                              }
                          }
      
                          ret[token] = grammar[token];
                      }
                  }
      
                  // Update references in other language definitions
                  _.languages.DFS(_.languages, function(key, value) {
                      if (value === root[inside] && key != inside) {
                          this[key] = ret;
                      }
                  });
      
                  return root[inside] = ret;
              },
      
              // Traverse a language definition with Depth First Search
              DFS: function(o, callback, type, visited) {
                  visited = visited || {};
                  for (var i in o) {
                      if (o.hasOwnProperty(i)) {
                          callback.call(o, i, o[i], type || i);
      
                          if (_.util.type(o[i]) === 'Object' && !visited[_.util.objId(o[i])]) {
                              visited[_.util.objId(o[i])] = true;
                              _.languages.DFS(o[i], callback, null, visited);
                          }
                          else if (_.util.type(o[i]) === 'Array' && !visited[_.util.objId(o[i])]) {
                              visited[_.util.objId(o[i])] = true;
                              _.languages.DFS(o[i], callback, i, visited);
                          }
                      }
                  }
              }
          },
          plugins: {},
      
          highlightAll: function(async, callback) {
              _.highlightAllUnder(document, async, callback);
          },
      
          highlightAllUnder: function(container, async, callback) {
              var env = {
                  callback: callback,
                  selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
              };
      
              _.hooks.run("before-highlightall", env);
      
              var elements = env.elements || container.querySelectorAll(env.selector);
      
              for (var i=0, element; element = elements[i++];) {
                  _.highlightElement(element, async === true, env.callback);
              }
          },
      
          highlightElement: function(element, async, callback) {
              // Find language
              var language, grammar, parent = element;
      
              while (parent && !lang.test(parent.className)) {
                  parent = parent.parentNode;
              }
      
              if (parent) {
                  language = (parent.className.match(lang) || [,''])[1].toLowerCase();
                  grammar = _.languages[language];
              }
      
              // Set language on the element, if not present
              element.className = element.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;
      
              if (element.parentNode) {
                  // Set language on the parent, for styling
                  parent = element.parentNode;
      
                  if (/pre/i.test(parent.nodeName)) {
                      parent.className = parent.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;
                  }
              }
      
              var code = element.textContent;
      
              var env = {
                  element: element,
                  language: language,
                  grammar: grammar,
                  code: code
              };
      
              _.hooks.run('before-sanity-check', env);
      
              if (!env.code || !env.grammar) {
                  if (env.code) {
                      _.hooks.run('before-highlight', env);
                      env.element.textContent = env.code;
                      _.hooks.run('after-highlight', env);
                  }
                  _.hooks.run('complete', env);
                  return;
              }
      
              _.hooks.run('before-highlight', env);
      
              if (async && _self.Worker) {
                  var worker = new Worker(_.filename);
      
                  worker.onmessage = function(evt) {
                      env.highlightedCode = evt.data;
      
                      _.hooks.run('before-insert', env);
      
                      env.element.innerHTML = env.highlightedCode;
      
                      callback && callback.call(env.element);
                      _.hooks.run('after-highlight', env);
                      _.hooks.run('complete', env);
                  };
      
                  worker.postMessage(JSON.stringify({
                      language: env.language,
                      code: env.code,
                      immediateClose: true
                  }));
              }
              else {
                  env.highlightedCode = _.highlight(env.code, env.grammar, env.language);
      
                  _.hooks.run('before-insert', env);
      
                  env.element.innerHTML = env.highlightedCode;
      
                  callback && callback.call(element);
      
                  _.hooks.run('after-highlight', env);
                  _.hooks.run('complete', env);
              }
          },
      
          highlight: function (text, grammar, language) {
              var env = {
                  code: text,
                  grammar: grammar,
                  language: language
              };
              _.hooks.run('before-tokenize', env);
              env.tokens = _.tokenize(env.code, env.grammar);
              _.hooks.run('after-tokenize', env);
              return Token.stringify(_.util.encode(env.tokens), env.language);
          },
      
          matchGrammar: function (text, strarr, grammar, index, startPos, oneshot, target) {
              var Token = _.Token;
      
              for (var token in grammar) {
                  if(!grammar.hasOwnProperty(token) || !grammar[token]) {
                      continue;
                  }
      
                  if (token == target) {
                      return;
                  }
      
                  var patterns = grammar[token];
                  patterns = (_.util.type(patterns) === "Array") ? patterns : [patterns];
      
                  for (var j = 0; j < patterns.length; ++j) {
                      var pattern = patterns[j],
                          inside = pattern.inside,
                          lookbehind = !!pattern.lookbehind,
                          greedy = !!pattern.greedy,
                          lookbehindLength = 0,
                          alias = pattern.alias;
      
                      if (greedy && !pattern.pattern.global) {
                          // Without the global flag, lastIndex won't work
                          var flags = pattern.pattern.toString().match(/[imuy]*$/)[0];
                          pattern.pattern = RegExp(pattern.pattern.source, flags + "g");
                      }
      
                      pattern = pattern.pattern || pattern;
      
                      // Donâ€™t cache length as it changes during the loop
                      for (var i = index, pos = startPos; i < strarr.length; pos += strarr[i].length, ++i) {
      
                          var str = strarr[i];
      
                          if (strarr.length > text.length) {
                              // Something went terribly wrong, ABORT, ABORT!
                              return;
                          }
      
                          if (str instanceof Token) {
                              continue;
                          }
      
                          if (greedy && i != strarr.length - 1) {
                              pattern.lastIndex = pos;
                              var match = pattern.exec(text);
                              if (!match) {
                                  break;
                              }
      
                              var from = match.index + (lookbehind ? match[1].length : 0),
                                  to = match.index + match[0].length,
                                  k = i,
                                  p = pos;
      
                              for (var len = strarr.length; k < len && (p < to || (!strarr[k].type && !strarr[k - 1].greedy)); ++k) {
                                  p += strarr[k].length;
                                  // Move the index i to the element in strarr that is closest to from
                                  if (from >= p) {
                                      ++i;
                                      pos = p;
                                  }
                              }
      
                              // If strarr[i] is a Token, then the match starts inside another Token, which is invalid
                              if (strarr[i] instanceof Token) {
                                  continue;
                              }
      
                              // Number of tokens to delete and replace with the new match
                              delNum = k - i;
                              str = text.slice(pos, p);
                              match.index -= pos;
                          } else {
                              pattern.lastIndex = 0;
      
                              var match = pattern.exec(str),
                                  delNum = 1;
                          }
      
                          if (!match) {
                              if (oneshot) {
                                  break;
                              }
      
                              continue;
                          }
      
                          if(lookbehind) {
                              lookbehindLength = match[1] ? match[1].length : 0;
                          }
      
                          var from = match.index + lookbehindLength,
                              match = match[0].slice(lookbehindLength),
                              to = from + match.length,
                              before = str.slice(0, from),
                              after = str.slice(to);
      
                          var args = [i, delNum];
      
                          if (before) {
                              ++i;
                              pos += before.length;
                              args.push(before);
                          }
      
                          var wrapped = new Token(token, inside? _.tokenize(match, inside) : match, alias, match, greedy);
      
                          args.push(wrapped);
      
                          if (after) {
                              args.push(after);
                          }
      
                          Array.prototype.splice.apply(strarr, args);
      
                          if (delNum != 1)
                              _.matchGrammar(text, strarr, grammar, i, pos, true, token);
      
                          if (oneshot)
                              break;
                      }
                  }
              }
          },
      
          tokenize: function(text, grammar, language) {
              var strarr = [text];
      
              var rest = grammar.rest;
      
              if (rest) {
                  for (var token in rest) {
                      grammar[token] = rest[token];
                  }
      
                  delete grammar.rest;
              }
      
              _.matchGrammar(text, strarr, grammar, 0, 0, false);
      
              return strarr;
          },
      
          hooks: {
              all: {},
      
              add: function (name, callback) {
                  var hooks = _.hooks.all;
      
                  hooks[name] = hooks[name] || [];
      
                  hooks[name].push(callback);
              },
      
              run: function (name, env) {
                  var callbacks = _.hooks.all[name];
      
                  if (!callbacks || !callbacks.length) {
                      return;
                  }
      
                  for (var i=0, callback; callback = callbacks[i++];) {
                      callback(env);
                  }
              }
          }
      };
      
      var Token = _.Token = function(type, content, alias, matchedStr, greedy) {
          this.type = type;
          this.content = content;
          this.alias = alias;
          // Copy of the full string this token was created from
          this.length = (matchedStr || "").length|0;
          this.greedy = !!greedy;
      };
      
      Token.stringify = function(o, language, parent) {
          if (typeof o == 'string') {
              return o;
          }
      
          if (_.util.type(o) === 'Array') {
              return o.map(function(element) {
                  return Token.stringify(element, language, o);
              }).join('');
          }
      
          var env = {
              type: o.type,
              content: Token.stringify(o.content, language, parent),
              tag: 'span',
              classes: ['token', o.type],
              attributes: {},
              language: language,
              parent: parent
          };
      
          if (o.alias) {
              var aliases = _.util.type(o.alias) === 'Array' ? o.alias : [o.alias];
              Array.prototype.push.apply(env.classes, aliases);
          }
      
          _.hooks.run('wrap', env);
      
          var attributes = Object.keys(env.attributes).map(function(name) {
              return name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
          }).join(' ');
      
          return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + (attributes ? ' ' + attributes : '') + '>' + env.content + '</' + env.tag + '>';
      
      };
      
      if (!_self.document) {
          if (!_self.addEventListener) {
              // in Node.js
              return _self.Prism;
          }
      
          if (!_.disableWorkerMessageHandler) {
              // In worker
              _self.addEventListener('message', function (evt) {
                  var message = JSON.parse(evt.data),
                      lang = message.language,
                      code = message.code,
                      immediateClose = message.immediateClose;
      
                  _self.postMessage(_.highlight(code, _.languages[lang], lang));
                  if (immediateClose) {
                      _self.close();
                  }
              }, false);
          }
      
          return _self.Prism;
      }
      
      //Get current script and highlight
      var script = document.currentScript || [].slice.call(document.getElementsByTagName("script")).pop();
      
      if (script) {
          _.filename = script.src;
      
          if (!_.manual && !script.hasAttribute('data-manual')) {
              if(document.readyState !== "loading") {
                  if (window.requestAnimationFrame) {
                      window.requestAnimationFrame(_.highlightAll);
                  } else {
                      window.setTimeout(_.highlightAll, 16);
                  }
              }
              else {
                  document.addEventListener('DOMContentLoaded', _.highlightAll);
              }
          }
      }
      
      return _self.Prism;
      
      })();
      
      if (typeof module !== 'undefined' && module.exports) {
          module.exports = Prism;
      }
      
      // hack for components to work correctly in node.js
      if (typeof global !== 'undefined') {
          global.Prism = Prism;
      }
      ;
      Prism.languages.clike = {
          'comment': [
              {
                  pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
                  lookbehind: true
              },
              {
                  pattern: /(^|[^\\:])\/\/.*/,
                  lookbehind: true,
                  greedy: true
              }
          ],
          'string': {
              pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
              greedy: true
          },
          'class-name': {
              pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i,
              lookbehind: true,
              inside: {
                  punctuation: /[.\\]/
              }
          },
          'keyword': /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
          'boolean': /\b(?:true|false)\b/,
          'function': /[a-z0-9_]+(?=\()/i,
          'number': /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i,
          'operator': /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,
          'punctuation': /[{}[\];(),.:]/
      };
      
      Prism.languages.c = Prism.languages.extend('clike', {
          'keyword': /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|asm|typeof|inline|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|size_t|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while)\b/,
          'operator': /-[>-]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/]/,
          'number': /(?:\b0x[\da-f]+|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?)[ful]*/i
      });
      
      Prism.languages.insertBefore('c', 'string', {
          'macro': {
              // allow for multiline macro definitions
              // spaces after the # character compile fine with gcc
              pattern: /(^\s*)#\s*[a-z]+(?:[^\r\n\\]|\\(?:\r\n|[\s\S]))*/im,
              lookbehind: true,
              alias: 'property',
              inside: {
                  // highlight the path of the include statement as a string
                  'string': {
                      pattern: /(#\s*include\s*)(?:<.+?>|("|')(?:\\?.)+?\2)/,
                      lookbehind: true
                  },
                  // highlight macro directives as keywords
                  'directive': {
                      pattern: /(#\s*)\b(?:define|defined|elif|else|endif|error|ifdef|ifndef|if|import|include|line|pragma|undef|using)\b/,
                      lookbehind: true,
                      alias: 'keyword'
                  }
              }
          },
          // highlight predefined macros as constants
          'constant': /\b(?:__FILE__|__LINE__|__DATE__|__TIME__|__TIMESTAMP__|__func__|EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|stdin|stdout|stderr)\b/
      });
      
      delete Prism.languages.c['class-name'];
      delete Prism.languages.c['boolean'];
      
      (function(Prism) {
          var insideString = {
              variable: [
                  // Arithmetic Environment
                  {
                      pattern: /\$?\(\([\s\S]+?\)\)/,
                      inside: {
                          // If there is a $ sign at the beginning highlight $(( and )) as variable
                          variable: [{
                                  pattern: /(^\$\(\([\s\S]+)\)\)/,
                                  lookbehind: true
                              },
                              /^\$\(\(/
                          ],
                          number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:[Ee]-?\d+)?/,
                          // Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic
                          operator: /--?|-=|\+\+?|\+=|!=?|~|\*\*?|\*=|\/=?|%=?|<<=?|>>=?|<=?|>=?|==?|&&?|&=|\^=?|\|\|?|\|=|\?|:/,
                          // If there is no $ sign at the beginning highlight (( and )) as punctuation
                          punctuation: /\(\(?|\)\)?|,|;/
                      }
                  },
                  // Command Substitution
                  {
                      pattern: /\$\([^)]+\)|`[^`]+`/,
                      greedy: true,
                      inside: {
                          variable: /^\$\(|^`|\)$|`$/
                      }
                  },
                  /\$(?:[\w#?*!@]+|\{[^}]+\})/i
              ]
          };
      
          Prism.languages.bash = {
              'shebang': {
                  pattern: /^#!\s*\/bin\/bash|^#!\s*\/bin\/sh/,
                  alias: 'important'
              },
              'comment': {
                  pattern: /(^|[^"{\\])#.*/,
                  lookbehind: true
              },
              'string': [
                  //Support for Here-Documents https://en.wikipedia.org/wiki/Here_document
                  {
                      pattern: /((?:^|[^<])<<\s*)["']?(\w+?)["']?\s*\r?\n(?:[\s\S])*?\r?\n\2/,
                      lookbehind: true,
                      greedy: true,
                      inside: insideString
                  },
                  {
                      pattern: /(["'])(?:\\[\s\S]|\$\([^)]+\)|`[^`]+`|(?!\1)[^\\])*\1/,
                      greedy: true,
                      inside: insideString
                  }
              ],
              'variable': insideString.variable,
              // Originally based on http://ss64.com/bash/
              'function': {
                  pattern: /(^|[\s;|&])(?:!!|!-2|!c|alias|apropos|apt-get|aptitude|aspell|awk|basename|bash|bc|bg|builtin|bzip2|cal|cat|cd|cfdisk|chgrp|chmod|chown|chroot|chkconfig|cksum|clear|cmp|comm|command|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|du|egrep|eject|enable|env|ethtool|eval|exec|expand|expect|export|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|gcc|getopts|git|grep|groupadd|groupdel|groupmod|groups|gzip|hash|head|help|hg|history|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|info|jobs|join|kill|killall|less|link|ln|locate|logname|logout|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|make|man|mkdir|mkfifo|mkisofs|mknod|more|most|mount|mtools|mtr|mv|mmv|nano|netstat|nice|nl|nohup|notify-send|npm|nslookup|open|op|passwd|paste|pathchk|ping|pkg-config|pkill|popd|pr|printcap|printenv|printf|ps|pushd|pv|pwd|quota|quotacheck|quotactl|ram|rar|rcp|read|readarray|readonly|reboot|rename|renice|remsync|rev|rm|rmdir|rsync|screen|scp|sdiff|sed|seq|service|sftp|shift|shopt|shutdown|sleep|slocate|sort|source|split|ssh|stat|strace|su|sudo|sum|suspend|sync|tail|tar|tee|test|time|timeout|times|touch|top|traceroute|trap|tr|tree|tsort|tty|type|ulimit|umask|umount|unalias|uname|unexpand|uniq|units|unrar|unshar|uptime|useradd|userdel|usermod|users|uuencode|uudecode|v|vdir|vi|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yes|zip)(?=$|[\s;|&])/,
                  lookbehind: true
              },
              'keyword': {
                  pattern: /(^|[\s;|&])(?:let|:|\.|if|then|else|elif|fi|for|break|continue|while|in|case|function|select|do|done|until|echo|exit|return|set|declare)(?=$|[\s;|&])/,
                  lookbehind: true
              },
              'boolean': {
                  pattern: /(^|[\s;|&])(?:true|false)(?=$|[\s;|&])/,
                  lookbehind: true
              },
              'operator': /&&?|\|\|?|==?|!=?|<<<?|>>|<=?|>=?|=~/,
              'punctuation': /\$?\(\(?|\)\)?|\.\.|[{}[\];]/
          };
      
          var inside = insideString.variable[1].inside;
          inside.string = Prism.languages.bash.string;
          inside['function'] = Prism.languages.bash['function'];
          inside.keyword = Prism.languages.bash.keyword;
          inside['boolean'] = Prism.languages.bash['boolean'];
          inside.operator = Prism.languages.bash.operator;
          inside.punctuation = Prism.languages.bash.punctuation;
          
          Prism.languages.shell = Prism.languages.bash;
      })(Prism);
      
      Prism.languages.makefile = {
          'comment': {
              pattern: /(^|[^\\])#(?:\\(?:\r\n|[\s\S])|[^\\\r\n])*/,
              lookbehind: true
          },
          'string': {
              pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
              greedy: true
          },
      
          // Built-in target names
          'builtin': /\.[A-Z][^:#=\s]+(?=\s*:(?!=))/,
      
          // Targets
          'symbol': {
              pattern: /^[^:=\r\n]+(?=\s*:(?!=))/m,
              inside: {
                  'variable': /\$+(?:[^(){}:#=\s]+|(?=[({]))/
              }
          },
          'variable': /\$+(?:[^(){}:#=\s]+|\([@*%<^+?][DF]\)|(?=[({]))/,
      
          'keyword': [
              // Directives
              /-include\b|\b(?:define|else|endef|endif|export|ifn?def|ifn?eq|include|override|private|sinclude|undefine|unexport|vpath)\b/,
              // Functions
              {
                  pattern: /(\()(?:addsuffix|abspath|and|basename|call|dir|error|eval|file|filter(?:-out)?|findstring|firstword|flavor|foreach|guile|if|info|join|lastword|load|notdir|or|origin|patsubst|realpath|shell|sort|strip|subst|suffix|value|warning|wildcard|word(?:s|list)?)(?=[ \t])/,
                  lookbehind: true
              }
          ],
          'operator': /(?:::|[?:+!])?=|[|@]/,
          'punctuation': /[:;(){}]/
      };
      (function () {
      
          if (typeof self === 'undefined' || !self.Prism || !self.document) {
              return;
          }
      
          /**
           * Plugin name which is used as a class name for <pre> which is activating the plugin
           * @type {String}
           */
          var PLUGIN_NAME = 'line-numbers';
          
          /**
           * Regular expression used for determining line breaks
           * @type {RegExp}
           */
          var NEW_LINE_EXP = /\n(?!$)/g;
      
          /**
           * Resizes line numbers spans according to height of line of code
           * @param {Element} element <pre> element
           */
          var _resizeElement = function (element) {
              var codeStyles = getStyles(element);
              var whiteSpace = codeStyles['white-space'];
      
              if (whiteSpace === 'pre-wrap' || whiteSpace === 'pre-line') {
                  var codeElement = element.querySelector('code');
                  var lineNumbersWrapper = element.querySelector('.line-numbers-rows');
                  var lineNumberSizer = element.querySelector('.line-numbers-sizer');
                  var codeLines = codeElement.textContent.split(NEW_LINE_EXP);
      
                  if (!lineNumberSizer) {
                      lineNumberSizer = document.createElement('span');
                      lineNumberSizer.className = 'line-numbers-sizer';
      
                      codeElement.appendChild(lineNumberSizer);
                  }
      
                  lineNumberSizer.style.display = 'block';
      
                  codeLines.forEach(function (line, lineNumber) {
                      lineNumberSizer.textContent = line || '\n';
                      var lineSize = lineNumberSizer.getBoundingClientRect().height;
                      lineNumbersWrapper.children[lineNumber].style.height = lineSize + 'px';
                  });
      
                  lineNumberSizer.textContent = '';
                  lineNumberSizer.style.display = 'none';
              }
          };
      
          /**
           * Returns style declarations for the element
           * @param {Element} element
           */
          var getStyles = function (element) {
              if (!element) {
                  return null;
              }
      
              return window.getComputedStyle ? getComputedStyle(element) : (element.currentStyle || null);
          };
      
          window.addEventListener('resize', function () {
              Array.prototype.forEach.call(document.querySelectorAll('pre.' + PLUGIN_NAME), _resizeElement);
          });
      
          Prism.hooks.add('complete', function (env) {
              if (!env.code) {
                  return;
              }
      
              // works only for <code> wrapped inside <pre> (not inline)
              var pre = env.element.parentNode;
              var clsReg = /\s*\bline-numbers\b\s*/;
              if (
                  !pre || !/pre/i.test(pre.nodeName) ||
                  // Abort only if nor the <pre> nor the <code> have the class
                  (!clsReg.test(pre.className) && !clsReg.test(env.element.className))
              ) {
                  return;
              }
      
              if (env.element.querySelector('.line-numbers-rows')) {
                  // Abort if line numbers already exists
                  return;
              }
      
              if (clsReg.test(env.element.className)) {
                  // Remove the class 'line-numbers' from the <code>
                  env.element.className = env.element.className.replace(clsReg, ' ');
              }
              if (!clsReg.test(pre.className)) {
                  // Add the class 'line-numbers' to the <pre>
                  pre.className += ' line-numbers';
              }
      
              var match = env.code.match(NEW_LINE_EXP);
              var linesNum = match ? match.length + 1 : 1;
              var lineNumbersWrapper;
      
              var lines = new Array(linesNum + 1);
              lines = lines.join('<span></span>');
      
              lineNumbersWrapper = document.createElement('span');
              lineNumbersWrapper.setAttribute('aria-hidden', 'true');
              lineNumbersWrapper.className = 'line-numbers-rows';
              lineNumbersWrapper.innerHTML = lines;
      
              if (pre.hasAttribute('data-start')) {
                  pre.style.counterReset = 'linenumber ' + (parseInt(pre.getAttribute('data-start'), 10) - 1);
              }
      
              env.element.appendChild(lineNumbersWrapper);
      
              _resizeElement(pre);
      
              Prism.hooks.run('line-numbers', env);
          });
      
          Prism.hooks.add('line-numbers', function (env) {
              env.plugins = env.plugins || {};
              env.plugins.lineNumbers = true;
          });
          
          /**
           * Global exports
           */
          Prism.plugins.lineNumbers = {
              /**
               * Get node for provided line number
               * @param {Element} element pre element
               * @param {Number} number line number
               * @return {Element|undefined}
               */
              getLine: function (element, number) {
                  if (element.tagName !== 'PRE' || !element.classList.contains(PLUGIN_NAME)) {
                      return;
                  }
      
                  var lineNumberRows = element.querySelector('.line-numbers-rows');
                  var lineNumberStart = parseInt(element.getAttribute('data-start'), 10) || 1;
                  var lineNumberEnd = lineNumberStart + (lineNumberRows.children.length - 1);
      
                  if (number < lineNumberStart) {
                      number = lineNumberStart;
                  }
                  if (number > lineNumberEnd) {
                      number = lineNumberEnd;
                  }
      
                  var lineIndex = number - lineNumberStart;
      
                  return lineNumberRows.children[lineIndex];
              }
          };
      
      }());
      (function() {
      
      var assign = Object.assign || function (obj1, obj2) {
          for (var name in obj2) {
              if (obj2.hasOwnProperty(name))
                  obj1[name] = obj2[name];
          }
          return obj1;
      }
      
      function NormalizeWhitespace(defaults) {
          this.defaults = assign({}, defaults);
      }
      
      function toCamelCase(value) {
          return value.replace(/-(\w)/g, function(match, firstChar) {
              return firstChar.toUpperCase();
          });
      }
      
      function tabLen(str) {
          var res = 0;
          for (var i = 0; i < str.length; ++i) {
              if (str.charCodeAt(i) == '\t'.charCodeAt(0))
                  res += 3;
          }
          return str.length + res;
      }
      
      NormalizeWhitespace.prototype = {
          setDefaults: function (defaults) {
              this.defaults = assign(this.defaults, defaults);
          },
          normalize: function (input, settings) {
              settings = assign(this.defaults, settings);
      
              for (var name in settings) {
                  var methodName = toCamelCase(name);
                  if (name !== "normalize" && methodName !== 'setDefaults' &&
                          settings[name] && this[methodName]) {
                      input = this[methodName].call(this, input, settings[name]);
                  }
              }
      
              return input;
          },
      
          /*
           * Normalization methods
           */
          leftTrim: function (input) {
              return input.replace(/^\s+/, '');
          },
          rightTrim: function (input) {
              return input.replace(/\s+$/, '');
          },
          tabsToSpaces: function (input, spaces) {
              spaces = spaces|0 || 4;
              return input.replace(/\t/g, new Array(++spaces).join(' '));
          },
          spacesToTabs: function (input, spaces) {
              spaces = spaces|0 || 4;
              return input.replace(new RegExp(' {' + spaces + '}', 'g'), '\t');
          },
          removeTrailing: function (input) {
              return input.replace(/\s*?$/gm, '');
          },
          // Support for deprecated plugin remove-initial-line-feed
          removeInitialLineFeed: function (input) {
              return input.replace(/^(?:\r?\n|\r)/, '');
          },
          removeIndent: function (input) {
              var indents = input.match(/^[^\S\n\r]*(?=\S)/gm);
      
              if (!indents || !indents[0].length)
                  return input;
      
              indents.sort(function(a, b){return a.length - b.length; });
      
              if (!indents[0].length)
                  return input;
      
              return input.replace(new RegExp('^' + indents[0], 'gm'), '');
          },
          indent: function (input, tabs) {
              return input.replace(/^[^\S\n\r]*(?=\S)/gm, new Array(++tabs).join('\t') + '$&');
          },
          breakLines: function (input, characters) {
              characters = (characters === true) ? 80 : characters|0 || 80;
      
              var lines = input.split('\n');
              for (var i = 0; i < lines.length; ++i) {
                  if (tabLen(lines[i]) <= characters)
                      continue;
      
                  var line = lines[i].split(/(\s+)/g),
                      len = 0;
      
                  for (var j = 0; j < line.length; ++j) {
                      var tl = tabLen(line[j]);
                      len += tl;
                      if (len > characters) {
                          line[j] = '\n' + line[j];
                          len = tl;
                      }
                  }
                  lines[i] = line.join('');
              }
              return lines.join('\n');
          }
      };
      
      // Support node modules
      if (typeof module !== 'undefined' && module.exports) {
          module.exports = NormalizeWhitespace;
      }
      
      // Exit if prism is not loaded
      if (typeof Prism === 'undefined') {
          return;
      }
      
      Prism.plugins.NormalizeWhitespace = new NormalizeWhitespace({
          'remove-trailing': true,
          'remove-indent': true,
          'left-trim': true,
          'right-trim': true,
          /*'break-lines': 80,
          'indent': 2,
          'remove-initial-line-feed': false,
          'tabs-to-spaces': 4,
          'spaces-to-tabs': 4*/
      });
      
      Prism.hooks.add('before-sanity-check', function (env) {
          var Normalizer = Prism.plugins.NormalizeWhitespace;
      
          // Check settings
          if (env.settings && env.settings['whitespace-normalization'] === false) {
              return;
          }
      
          // Simple mode if there is no env.element
          if ((!env.element || !env.element.parentNode) && env.code) {
              env.code = Normalizer.normalize(env.code, env.settings);
              return;
          }
      
          // Normal mode
          var pre = env.element.parentNode;
          var clsReg = /\bno-whitespace-normalization\b/;
          if (!env.code || !pre || pre.nodeName.toLowerCase() !== 'pre' ||
                  clsReg.test(pre.className) || clsReg.test(env.element.className))
              return;
      
          var children = pre.childNodes,
              before = '',
              after = '',
              codeFound = false;
      
          // Move surrounding whitespace from the <pre> tag into the <code> tag
          for (var i = 0; i < children.length; ++i) {
              var node = children[i];
      
              if (node == env.element) {
                  codeFound = true;
              } else if (node.nodeName === "#text") {
                  if (codeFound) {
                      after += node.nodeValue;
                  } else {
                      before += node.nodeValue;
                  }
      
                  pre.removeChild(node);
                  --i;
              }
          }
      
          if (!env.element.children.length || !Prism.plugins.KeepMarkup) {
              env.code = before + env.code + after;
              env.code = Normalizer.normalize(env.code, env.settings);
          } else {
              // Preserve markup for keep-markup plugin
              var html = before + env.element.innerHTML + after;
              env.element.innerHTML = Normalizer.normalize(html, env.settings);
              env.code = env.element.textContent;
          }
      });
      
      }());
      var previous = 0;
      var derniere_position_de_scroll_connue = 0;
      var ticking = false;
      var header = document.querySelector("header");
      
      function faitQuelquechose(old_pos, new_pos) {
        if (new_pos - old_pos > 0)
            header.style.top = "-2em";
        else
            header.style.top = "0em";
      
      }
      
      window.addEventListener('scroll', function(e) {
          var old = derniere_position_de_scroll_connue;
        derniere_position_de_scroll_connue = window.scrollY;
        if (!ticking) {
          window.requestAnimationFrame(function() {
            faitQuelquechose(old, derniere_position_de_scroll_connue);
            ticking = false;
          });
        }
        ticking = true;
      });
      
      var global_id = 1000
      
      function open_tag(tagName, id)
      {
          return "<" + tagName.toLowerCase() + "><a href=\"#" + id + "\">";
      }
      
      function close_tag(tagName)
      {
          return "</a></" + tagName.toLowerCase() + ">";
      }
      
      var nav = document.querySelector("nav");
      
      if (nav !== null)
      {
          var hs = document.querySelectorAll("h2, h3, h4");
          var tc = "";
          var n = 0;
      
          for (var i = 0; i < hs.length; i++)
          {
              var tagName = hs[i].tagName;
      
              if (hs[i].id == "")
                  hs[i].id = "head_" + global_id++;
      
              var qn = "";
              if (hs[i].className == "question")
                  qn = ++n + ". ";
      
              tc += open_tag(tagName, hs[i].id) + qn + hs[i].innerText + close_tag(tagName);
          }
      
          nav.innerHTML = tc;
      }
          </script>

    </head>
    <body>
        <div class="title">
            <div class="practical_number">Practical Work #2</div>
            <h1>Pointers</h1>
        </div>
        <nav id="table_of_contents"></nav>
        <main>
            <h2>Submission</h2>
            <h3>Due Date</h3>
            <p>By Monday 2 October 2023 11:42 am</p>
            <h3>Directory Hierarchy</h3>
            <p>
                When you are done, your git repository must contain the following files and directories:
            </p>
            <pre class=" language-none"><code class=" language-none">$ tree
.
├── arrays
│   ├── helper.c
│   ├── helper.h
│   ├── insert_sort.c
│   ├── insert_sort.h
│   ├── main.c
│   └── Makefile
├── AUTHORS
├── strings
│   └── mystrncpy.c
└── warmup
    ├── arithmetic.c
    ├── sum_of_divisors.c
    └── swap.c</code></pre>
            <p>
                The <code class="s">AUTHORS</code> file
                must contain the following information.
            </p>
            <div class="filename">AUTHORS</div>
            <pre class="line-numbers language-bash"><code class=" language-bash">First Name
Family Name
Login
Email Address<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
            <p>
                The last character of your <code class="s">AUTHORS</code> file must be a newline character.
            </p>
            <p>For instance:</p>
            <div class="filename">AUTHORS</div>
            <pre class=" language-bash"><code class=" language-bash">$ <span class="token function">cat</span> AUTHORS
John
Smith
john.smith
john.smith@epita.fr
$ <span class="token comment"># Command prompt ready for the next command...</span></code></pre>
            <p>
                <mark>
                    Be careful, if you do not follow all the given instructions,
                    no point will be given to your answers.
                </mark>
            </p>
            <h2>Warm-up Exercices</h2>
            <h3>Introduction</h3>
            <p>
                In this part, you will complete some source files
                (with the <code class="s">.c</code> extension).
                Each of them must be compiled with the instruction below
                (replace <code class="s">source.c</code> by the name of your source file).
            </p>
            <pre class=" language-bash"><code class=" language-bash">$ <span class="token function">gcc</span> -Wall -Wextra source.c</code></pre>
            <p>
                No <i>makefile</i> is required.
            </p>
            <h3>Basic Pointers</h3>
            <h4>Swapping Variables</h4>
            <p>
                Write a function that swaps the contents of two variables.
                To do so, complete the following file.
            </p>
            <div class="filename">swap.c</div>
            <pre class=" language-c"><code class=" language-c"><span class="token macro property"># <span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>b<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// TODO</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a = %d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"b = %d\n"</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a = %d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"b = %d\n"</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
            <p>
                Then, compile it and run it. The expected result is as follows:
            </p>
            <pre class=" language-bash"><code class=" language-bash">$ <span class="token function">gcc</span> -Wall -Wextra swap.c
$ ./a.out
a <span class="token operator">=</span> 1
b <span class="token operator">=</span> 2
a <span class="token operator">=</span> 2
b <span class="token operator">=</span> 1</code></pre>
            <h4>Sum of Divisors</h4>
            <p>
                Write the following function:
            </p>
            <pre class=" language-c"><code class=" language-c"><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">sum_of_divisors</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> n<span class="token punctuation">,</span> <span class="token keyword">size_t</span> <span class="token operator">*</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
            <ul>
                <li>
                    <b>Arguments:</b>
                    <ul>
                        <li><var>n</var>: 64-bit unsigned integer (0 excluded).</li>
                    </ul>
                    <ul>
                        <li><var>count</var>: Return the number of divisors of <var>n</var>.</li>
                    </ul>
                </li>
                <li>
                    <b>Return Value:</b> the sum of the divisors of <var>n</var>
                    (excluding <var>n</var>).
                </li>
            </ul>
            <p>
                To do so, complete the following file.
            </p>
            <div class="filename">sum_of_divisors.c</div>
            <pre class=" language-c"><code class=" language-c"><span class="token macro property"># <span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">sum_of_divisors</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> n<span class="token punctuation">,</span> <span class="token keyword">size_t</span> <span class="token operator">*</span>count<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// TODO</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> x<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> sum<span class="token punctuation">;</span>
    <span class="token keyword">size_t</span> count<span class="token punctuation">;</span>

    x <span class="token operator">=</span> <span class="token number">28</span><span class="token punctuation">;</span>
    sum <span class="token operator">=</span> <span class="token function">sum_of_divisors</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token operator">&amp;</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"x = %lu\n"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sum   = %lu\n"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"count = %zu\n\n"</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>

    x <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    sum <span class="token operator">=</span> <span class="token function">sum_of_divisors</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token operator">&amp;</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"x = %lu\n"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sum   = %lu\n"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"count = %zu\n"</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
            <p>
                Then, compile it and run it. The expected result is as follows:
            </p>
            <pre class="  language-bash"><code class=" language-bash">$ <span class="token function">gcc</span> -Wall -Wextra sum_of_divisors.c
$ ./a.out
x <span class="token operator">=</span> 28
s</code><code class=" language-bash">um   <span class="token operator">=</span> 28
count <span class="token operator">=</span> 5

x <span class="token operator">=</span> 100
s</code><code class=" language-bash">um   <span class="token operator">=</span> 117
count <span class="token operator">=</span> 8</code></pre>
            <h3>Pointer Arithmetic</h3>
            <p>
                For all the functions in this section, the <var>begin</var> variable points
                to the beginning of an array and the <var>end</var> variable
                points <b>just after</b> the array.
            </p>
            <p>
                Some hints:
            </p>
            <ul>
                <li>
                    The size of an array: <code>end - begin</code>
                </li>
                <li>
                    The i-index element: <code>*(begin + i)</code>
                </li>
                <li>
                    The first element: <code>*begin</code>
                </li>
                <li>
                    The last element: <code>*(end - 1)</code>
                </li>
            </ul>
            <p>
                <mark>
                    Of course, when iterating over arrays, do not use index variables.
                    Use pointers only. For instance:
                </mark>
            </p>
            <pre class=" language-c"><code class=" language-c"><span class="token keyword">for</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> begin<span class="token punctuation">;</span> p <span class="token operator">&lt;</span> end<span class="token punctuation">;</span> p<span class="token operator">++</span><span class="token punctuation">)</span>
  <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre>
            <p>
                Complete the following file.
            </p>
            <div class="filename">arithmetic.c</div>
            <pre class=" language-c"><code class=" language-c"><span class="token macro property"># <span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>begin <span class="token operator">=</span> arr<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>end <span class="token operator">=</span> arr <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> copy<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token macro property">#<span class="token directive keyword">define</span> PRINT(a) \
for (size_t i = 0; i &lt; size; i++)\
    if (i != size - 1)\
        printf("%2i, ", *(a + i));\
    else\
        printf("%2i]\n", *(a + i))\
</span>
<span class="token comment">// Swap the contents of two variables.</span>
<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// TODO</span>
    <span class="token comment">// (Just copy your code from the previous section.)</span>
<span class="token punctuation">}</span>

<span class="token comment">// Return the sum of the array from 'begin' to 'end'.</span>
<span class="token keyword">int</span> <span class="token function">array_sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>begin<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>end<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// TODO</span>
<span class="token punctuation">}</span>

<span class="token comment">// Reverse the array from 'begin' to 'end'.</span>
<span class="token keyword">void</span> <span class="token function">array_reverse</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>begin<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>end<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// TODO</span>
<span class="token punctuation">}</span>

<span class="token comment">// Copy the array from 'begin' to 'end' into 'dst'.</span>
<span class="token comment">// The dst array must be large enough.</span>
<span class="token comment">// The two arrays do not overlap.</span>
<span class="token keyword">void</span> <span class="token function">array_copy</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>dst<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>begin<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>end<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// TODO</span>
<span class="token punctuation">}</span>

<span class="token comment">// Shift the array from 'begin' to 'end' by one position to the right.</span>
<span class="token comment">// The leftmost value will not change.</span>
<span class="token comment">// The rightmost value will be lost.</span>
<span class="token comment">// For instance:</span>
<span class="token comment">// - Before: 1 2 3 4 5</span>
<span class="token comment">// - After:  1 1 2 3 4</span>
<span class="token keyword">void</span> <span class="token function">array_rshift</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>begin<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>end<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// TODO</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">size_t</span> size <span class="token operator">=</span> end <span class="token operator">-</span> begin<span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Initial arr  = ["</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">PRINT</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token function">array_sum</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sum          = %2i\n"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">array_reverse</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Reversed arr = ["</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">PRINT</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">array_copy</span><span class="token punctuation">(</span>copy<span class="token punctuation">,</span> begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Copy         = ["</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">PRINT</span><span class="token punctuation">(</span>copy<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">array_rshift</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">array_rshift</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">array_rshift</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Shifted arr  = ["</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">PRINT</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
            <p>
                Then, compile it and run it. The expected result is as follows:
            </p>
            <pre class="  language-bash"><code class=" language-bash">$ <span class="token function">gcc</span> -Wall -Wextra arithmetic.c
$ ./a.out
Initial arr  <span class="token operator">=</span> <span class="token punctuation">[</span> 1,  2,  3,  4,  5,  6,  7,  8,  9, 10<span class="token punctuation">]</span>
s</code><code class=" language-bash">um          <span class="token operator">=</span> 55
Reversed arr <span class="token operator">=</span> <span class="token punctuation">[</span>10,  9,  8,  7,  6,  5,  4,  3,  2,  1<span class="token punctuation">]</span>
Copy         <span class="token operator">=</span> <span class="token punctuation">[</span>10,  9,  8,  7,  6,  5,  4,  3,  2,  1<span class="token punctuation">]</span>
Shifted arr  <span class="token operator">=</span> <span class="token punctuation">[</span>10, 10, 10, 10,  9,  8,  7,  6,  5,  4<span class="token punctuation">]</span></code></pre>
            <h2>Arrays</h2>
            <h3>Provided Files</h3>
            <h4>The Makefile</h4>
            <p>
                Be careful, some source files must exist even if empty.
            </p>
            <div class="filename">Makefile</div>
            <pre class=" language-makefile"><code class=" language-makefile"><span class="token comment"># Makefile</span>

CC<span class="token operator">=</span>gcc -fsanitize<span class="token operator">=</span>address
CPPFLAGS<span class="token operator">=</span> -MMD -D_XOPEN_SOURCE<span class="token operator">=</span>500
CFLAGS<span class="token operator">=</span> -Wall -Wextra -std<span class="token operator">=</span>c99 -O2
LDFLAGS<span class="token operator">=</span>
LDLIBS<span class="token operator">=</span>

<span class="token comment"># You should at least create the "insert_sort.c"</span>
<span class="token comment"># and "insert_sort.h" files in order to compile.</span>
<span class="token comment"># (These files can be empty.)</span>

SRC<span class="token operator">=</span> insert_sort.c helper.c main.c
OBJ<span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">{</span>SRC<span class="token punctuation">:</span>.c<span class="token operator">=</span>.o<span class="token punctuation">}</span>
DEP<span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">{</span>SRC<span class="token punctuation">:</span>.c<span class="token operator">=</span>.d<span class="token punctuation">}</span>

<span class="token symbol">all</span><span class="token punctuation">:</span> main

<span class="token keyword">-include</span> <span class="token variable">$</span><span class="token punctuation">{</span>DEP<span class="token punctuation">}</span>

<span class="token symbol">main</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">{</span>OBJ<span class="token punctuation">}</span>

<span class="token symbol">clean</span><span class="token punctuation">:</span>
	rm -f <span class="token variable">$</span><span class="token punctuation">{</span>OBJ<span class="token punctuation">}</span> <span class="token variable">$</span><span class="token punctuation">{</span>DEP<span class="token punctuation">}</span> main

<span class="token comment"># END</span></code></pre>
            <h4>The <code>helper.h</code> File</h4>
            <div class="filename">helper.h</div>
            <pre class=" language-c"><code class=" language-c"><span class="token macro property"># <span class="token directive keyword">ifndef</span> _HELPER_H</span>
<span class="token macro property"># <span class="token directive keyword">define</span> _HELPER_H</span>

<span class="token macro property"># <span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"># <span class="token directive keyword">include</span> <span class="token string">&lt;time.h&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">array_print</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>begin<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">array_is_sorted</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>begin<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">array_sorted_fill</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>begin<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">array_random_fill</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>begin<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span>
<span class="token keyword">double</span> <span class="token function">time_gdiff</span><span class="token punctuation">(</span><span class="token keyword">struct</span> timespec t0<span class="token punctuation">,</span> <span class="token keyword">struct</span> timespec t1<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">double</span> s <span class="token operator">=</span> t1<span class="token punctuation">.</span>tv_sec <span class="token operator">-</span> t0<span class="token punctuation">.</span>tv_sec<span class="token punctuation">;</span>
  <span class="token keyword">return</span> s <span class="token operator">+</span> <span class="token punctuation">(</span>t1<span class="token punctuation">.</span>tv_nsec <span class="token operator">-</span> t0<span class="token punctuation">.</span>tv_nsec<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1e-9</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>sort_fun<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">bench_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>begin<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>end<span class="token punctuation">,</span> sort_fun sort<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token macro property"># <span class="token directive keyword">endif</span></span></code></pre>
            <h4>The <code>insert_sort.h</code> File</h4>
            <div class="filename">insert_sort.h</div>
            <pre class=" language-c"><code class=" language-c"><span class="token macro property"># <span class="token directive keyword">ifndef</span> _INSERT_SORT_H_</span>
<span class="token macro property"># <span class="token directive keyword">define</span> _INSERT_SORT_H_</span>

<span class="token macro property"># <span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"># <span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>

<span class="token macro property"># <span class="token directive keyword">include</span> <span class="token string">"helper.h"</span></span>

<span class="token keyword">void</span> <span class="token function">array_insert_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>begin<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">array_insert_sort_bin</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>begin<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token macro property"># <span class="token directive keyword">endif</span></span></code></pre>
            <h4 id="main_file">The Main File</h4>
            <p>
                You can use the following main file (you do not have to) in order to test your code.
                You can pass the size of the array as a parameter (the default size is 16).
                Also, try larger sizes (e.g. 32,768 or 65,536) and observe the differences in performance.
            </p>
            <p>
                Uncomment some lines of this file according to the functions you want to test.
                (Do not print an array if it is too large.)
            </p>
            <div class="filename">main.c</div>
            <pre class=" language-c"><code class=" language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;assert.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;err.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;time.h&gt;</span></span>

<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"helper.h"</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"insert_sort.h"</span></span>

<span class="token macro property">#<span class="token directive keyword">define</span> DEFAULT_SIZE 16</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">size_t</span> len <span class="token operator">=</span> DEFAULT_SIZE<span class="token punctuation">;</span>

    <span class="token function">srandom</span><span class="token punctuation">(</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span>
        len <span class="token operator">=</span> <span class="token function">strtoul</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> <span class="token operator">*</span>array <span class="token operator">=</span> <span class="token function">calloc</span><span class="token punctuation">(</span>len<span class="token punctuation">,</span> <span class="token keyword">sizeof</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>copy <span class="token operator">=</span> <span class="token function">calloc</span><span class="token punctuation">(</span>len<span class="token punctuation">,</span> <span class="token keyword">sizeof</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>begin <span class="token operator">=</span> array<span class="token punctuation">,</span> <span class="token operator">*</span>end <span class="token operator">=</span> array <span class="token operator">+</span> len<span class="token punctuation">;</span>

    <span class="token comment">// Fill the array with sorted values.</span>
    <span class="token function">array_sorted_fill</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Test the algorithms on a presorted array.</span>
    <span class="token comment">// -----------------------------------------------------------------------</span>
    <span class="token function">array_print</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">bench_sort</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> array_insert_sort<span class="token punctuation">,</span> <span class="token string">"insert_sort (sorted)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">array_print</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">bench_sort</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> array_insert_sort_bin<span class="token punctuation">,</span> <span class="token string">"insert_sort_bin (sorted)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">array_print</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Fill the array with random values</span>
    <span class="token comment">// and copy it in order to test the algorithms on the same array.</span>
    <span class="token comment">// -----------------------------------------------------------------------</span>
    <span class="token function">array_random_fill</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">memcpy</span><span class="token punctuation">(</span>copy<span class="token punctuation">,</span> begin<span class="token punctuation">,</span> len <span class="token operator">*</span> <span class="token keyword">sizeof</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Test the algorithms on a random array.</span>
    <span class="token comment">// -----------------------------------------------------------------------</span>
    <span class="token function">array_print</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">bench_sort</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> array_insert_sort<span class="token punctuation">,</span> <span class="token string">"insert_sort (random)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">array_print</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">memcpy</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> copy<span class="token punctuation">,</span> len <span class="token operator">*</span> <span class="token keyword">sizeof</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">array_print</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">bench_sort</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">,</span> array_insert_sort_bin<span class="token punctuation">,</span> <span class="token string">"insert_sort_bin (random)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">array_print</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// free memory</span>
    <span class="token function">free</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>copy<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
            <h3>Helper Functions</h3>
            <p>
                Complete the <code class="s">helper.c</code> file.
            </p>
            <div class="filename">helper.c</div>
            <pre class=" language-c"><code class=" language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;assert.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;time.h&gt;</span></span>

<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"helper.h"</span></span>

<span class="token comment">// Swap the contents of two variables.</span>
<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>b<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// TODO</span>
    <span class="token comment">// (Just copy your code from the previous section.)</span>
<span class="token punctuation">}</span>

<span class="token comment">// Print an array.</span>
<span class="token keyword">void</span> <span class="token function">array_print</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>begin<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>end<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> line <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> begin <span class="token operator">!=</span> end<span class="token punctuation">;</span> <span class="token operator">++</span>begin<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>line <span class="token operator">&gt;</span> <span class="token number">72</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"|`|\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            line <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        line <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"| %4d "</span><span class="token punctuation">,</span> <span class="token operator">*</span>begin<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"|\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Test if an array is sorted.</span>
<span class="token comment">// If the array is sorted, return true (1).</span>
<span class="token comment">// Otherwise, return false (0).</span>
<span class="token keyword">int</span> <span class="token function">array_is_sorted</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>begin<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>end<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// TODO</span>
<span class="token punctuation">}</span>

<span class="token comment">// Fill an array with sorted values.</span>
<span class="token keyword">void</span> <span class="token function">array_sorted_fill</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>begin<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>end<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> begin <span class="token operator">!=</span> end<span class="token punctuation">;</span> <span class="token operator">++</span>begin<span class="token punctuation">,</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
        <span class="token operator">*</span>begin <span class="token operator">=</span> i<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Fill an array with random values.</span>
<span class="token keyword">void</span> <span class="token function">array_random_fill</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>begin<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>end<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> begin <span class="token operator">!=</span> end<span class="token punctuation">;</span> <span class="token operator">++</span>begin<span class="token punctuation">)</span>
        <span class="token operator">*</span>begin <span class="token operator">=</span> <span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10000</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Benchmark an algorithm.</span>
<span class="token keyword">void</span> <span class="token function">bench_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>begin<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>end<span class="token punctuation">,</span> sort_fun sort<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>msg<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> timespec t0<span class="token punctuation">,</span> t1<span class="token punctuation">;</span>

    <span class="token function">clock_gettime</span><span class="token punctuation">(</span>CLOCK_MONOTONIC<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t0<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sort</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">clock_gettime</span><span class="token punctuation">(</span>CLOCK_MONOTONIC<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s:    \t%g\n"</span><span class="token punctuation">,</span> msg<span class="token punctuation">,</span> <span class="token function">time_gdiff</span><span class="token punctuation">(</span>t0<span class="token punctuation">,</span> t1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span><span class="token function">array_is_sorted</span><span class="token punctuation">(</span>begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
            <h3>Insertion Sort</h3>
            <p>
                You will write an <a href="https://en.wikipedia.org/wiki/Insertion_sort">insertion sort</a>.
                The algorithm is pretty simple.
                First, you write an <code class="s">insert()</code> function
                that inserts an element at its right place in a sorted array.
                Then, you take each element one by one and insert it in the first part of the array.
            </p>
            <pre class=" language-none"><code class=" language-none">insert_sort(array):
    for i in range(len(array)):
        insert(array[:i], array[i])</code></pre>
            <p>
                Inserting is also a pretty straightforward algorithm.
                Find where to insert the value, shift the right side
                of the array by one cell to the right and write the value.
                Here is a plain version of the algorithm
                (note that your array must have an extra cell).
            </p>
            <pre class=" language-none"><code class=" language-none">insert(array, x):
    i = len(array)
    array.append(None)
    while i &gt; 0 &amp;&amp; x &lt; array[i - 1]:
        array[i] = array[i - 1]
        i = i - 1
  array[i] = x</code></pre>
            <p>
                You can also use a faster algorithm by using the binary search.
            </p>
            <pre class=" language-none"><code class=" language-none">insert_bin(x, array):
    i = binary_search(x, array)
    j = len(array)
    array.append(None)
    while j &gt; i:
        array[j] = array[j - 1]
        j = j - 1
    array[i] = x</code></pre>
            <p>
                Remember, we always return the position where the element should be located.
                For shifting we can also use the
                <a href="https://manpages.debian.org/stretch/manpages-dev/memmove.3.en.html">memmove()</a>
                function.
            </p>
            <p>
                Create an <code class="s">insert_sort.c</code> file with the required headers
                and write the two following functions:
            </p>
            <pre class=" language-c"><code class=" language-c"><span class="token comment">// Insertion using the plain algorithm.</span>
<span class="token keyword">void</span> <span class="token function">array_insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>begin<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>end<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Insertion using the binary-search algorithm.</span>
<span class="token keyword">void</span> <span class="token function">array_insert_bin</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>begin<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>end<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
            <p>
                Try and test these two functions on your own.
                When this is done, you can implement the insertion sort (two versions again).
            </p>
            <pre class=" language-c"><code class=" language-c"><span class="token comment">// Insertion sort using plain method.</span>
<span class="token keyword">void</span> <span class="token function">array_insert_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>begin<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Insertion sort using binary search.</span>
<span class="token keyword">void</span> <span class="token function">array_insert_sort_bin</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>begin<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
            <p>
                Finally, you can either test the functions on your own
                or use the provided main file
                (see <a href="#main_file">above</a>).
            </p>
            <h2>Strings</h2>
            <h3>Introduction</h3>
            <p>
                In this section, you will manipulate strings <b>by using pointers only</b>.
                To do so, you will write some commonly used functions.
            </p>
            <p>
                <mark>
                    Obviously, you will not use the array notation with
                    index variables when iterating over arrays.
                    <b>You must use the pointer notation only.</b>
                </mark>
            </p>
            <p>
                In the C language, a string is no more than an array of characters.
                The end of a string is denoted by a special character,
                which is called the <strong>NULL character</strong>.
                The ASCII code of the NULL character is zero.
            </p>
            <p>
                The following code prints the numerical values
                (e.g. the ASCII codes) of some characters.
            </p>
            <pre class=" language-c"><code class=" language-c"><span class="token macro property"># <span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"abcdefghijklmnopqrstuvwxyz"</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">size_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"s[%2zu] = 0x%02x - '%c'\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
            <p>
                Its output is as follows:
            </p>
            <pre class=" language-none"><code class=" language-none">s[ 0] = 0x61 - 'a'
s[ 1] = 0x62 - 'b'
s[ 2] = 0x63 - 'c'
s[ 3] = 0x64 - 'd'
s[ 4] = 0x65 - 'e'
s[ 5] = 0x66 - 'f'
s[ 6] = 0x67 - 'g'
s[ 7] = 0x68 - 'h'
s[ 8] = 0x69 - 'i'
s[ 9] = 0x6a - 'j'
s[10] = 0x6b - 'k'
s[11] = 0x6c - 'l'
s[12] = 0x6d - 'm'
s[13] = 0x6e - 'n'
s[14] = 0x6f - 'o'
s[15] = 0x70 - 'p'
s[16] = 0x71 - 'q'
s[17] = 0x72 - 'r'
s[18] = 0x73 - 's'
s[19] = 0x74 - 't'
s[20] = 0x75 - 'u'
s[21] = 0x76 - 'v'
s[22] = 0x77 - 'w'
s[23] = 0x78 - 'x'
s[24] = 0x79 - 'y'
s[25] = 0x7a - 'z'
s[26] = 0x00 - ''</code></pre>
            <h3>Lengths of Strings</h3>
            <p>
                In the above example, we get the length of the array by using <code class="s">sizeof()</code>
                because the array was <code class="s">static</code>.
            </p>
            <p>
                Let us execute this other example.
            </p>
            <pre class=" language-c"><code class=" language-c"><span class="token macro property"># <span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">char</span> s1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"abcdefghijklmnopqrstuvwxyz"</span><span class="token punctuation">;</span>   <span class="token comment">// Array notation.</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>s2  <span class="token operator">=</span> <span class="token string">"abcdefghijklmnopqrstuvwxyz"</span><span class="token punctuation">;</span>   <span class="token comment">// Pointer notation.</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sizeof(s1) = %zu\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> <span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sizeof(s2) = %zu\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> <span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
            <p>
                Its output is as follows:
            </p>
            <pre class=" language-none"><code class=" language-none">sizeof(s1) = 27
sizeof(s2) = 8</code></pre>
            <p>
                When we use a pointer, the <code class="s">sizeof()</code> operator
                returns the size of the pointer (not the size of the array).
                So, if we want to know the size of a string, we have to count
                each character up to the NULL character.
                That is the purpose of the <code class="s">strlen()</code>
                function of the standard library.
                <b>Note that the length of a string does not include the NULL character.</b>
            </p>
            <p>
                This function is easy to write.
                Write the following function that has the same behavior
                as the one of the standard library (have a look at its
                <a href="https://manpages.debian.org/buster/manpages-dev/strlen.3.en.html">man page</a>).
            </p>
            <pre class=" language-c"><code class=" language-c"><span class="token keyword">size_t</span> <span class="token function">mystrlen</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
            <p>
                You will test your function in the next section.
            </p>
            <h3>Copying Strings</h3>
            <p>
                Copying strings is another very common operation on strings.
                The standard library provides two functions for this purpose:
                <code class="s">strcpy()</code> and <code class="s">strncpy()</code>.
                We will focus on the second one.
                Read its <a href="https://manpages.debian.org/stretch/manpages-dev/strncpy.3.en.html">man page</a>
                and write the following function that has exactly the same behavior.
            </p>
            <pre class=" language-c"><code class=" language-c"><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">mystrncpy</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>dst<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>src<span class="token punctuation">,</span> <span class="token keyword">size_t</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
            <p>
                Complete the following code and execute it to test your functions.
            </p>
            <div class="filename">mystrncpy.c</div>
            <pre class=" language-c"><code class=" language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>

<span class="token keyword">size_t</span> <span class="token function">mystrlen</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// TODO</span>
<span class="token punctuation">}</span>

<span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">mystrncpy</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>dst<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>src<span class="token punctuation">,</span> <span class="token keyword">size_t</span> len<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// TODO</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">print_str_as_array</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">size_t</span> len<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">size_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"0x%02x "</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">char</span> src<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>dst <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Fill dst with 0x7f.</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>cur <span class="token operator">=</span> dst<span class="token punctuation">;</span> cur <span class="token operator">&lt;</span> dst <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span> cur<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token operator">*</span>cur <span class="token operator">=</span> <span class="token number">0x7f</span><span class="token punctuation">;</span>

    <span class="token comment">// Print dst and src.</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"src = "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">print_str_as_array</span><span class="token punctuation">(</span>src<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"dst = "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">print_str_as_array</span><span class="token punctuation">(</span>dst<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Copy exactly the length of src.</span>
    <span class="token function">mystrncpy</span><span class="token punctuation">(</span>dst<span class="token punctuation">,</span> src<span class="token punctuation">,</span> <span class="token function">mystrlen</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\ndst = "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">print_str_as_array</span><span class="token punctuation">(</span>dst<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Fill dst with 0x7f.</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>cur <span class="token operator">=</span> dst<span class="token punctuation">;</span> cur <span class="token operator">&lt;</span> dst <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span> cur<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token operator">*</span>cur <span class="token operator">=</span> <span class="token number">0x7f</span><span class="token punctuation">;</span>

    <span class="token comment">// Copy the length of src + 1.</span>
    <span class="token function">mystrncpy</span><span class="token punctuation">(</span>dst<span class="token punctuation">,</span> src<span class="token punctuation">,</span> <span class="token function">mystrlen</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\ndst = "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">print_str_as_array</span><span class="token punctuation">(</span>dst<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Fill dst with 0x7f.</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>cur <span class="token operator">=</span> dst<span class="token punctuation">;</span> cur <span class="token operator">&lt;</span> dst <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span> cur<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token operator">*</span>cur <span class="token operator">=</span> <span class="token number">0x7f</span><span class="token punctuation">;</span>

    <span class="token comment">// Copy the size of dst.</span>
    <span class="token function">mystrncpy</span><span class="token punctuation">(</span>dst<span class="token punctuation">,</span> src<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\ndst = "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">print_str_as_array</span><span class="token punctuation">(</span>dst<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Fill dst with 0x7f.</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>cur <span class="token operator">=</span> dst<span class="token punctuation">;</span> cur <span class="token operator">&lt;</span> dst <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span> cur<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token operator">*</span>cur <span class="token operator">=</span> <span class="token number">0x7f</span><span class="token punctuation">;</span>

    <span class="token function">free</span><span class="token punctuation">(</span>dst<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
            <p>
                The expected result is as follows:
            </p>
            <pre class=" language-bash"><code class=" language-bash">$ <span class="token function">gcc</span> -Wall -Wextra mystrncpy.c
$ ./a.out
src <span class="token operator">=</span> 0x61 0x62 0x63 0x00
dst <span class="token operator">=</span> 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f

dst <span class="token operator">=</span> 0x61 0x62 0x63 0x7f 0x7f 0x7f 0x7f 0x7f

dst <span class="token operator">=</span> 0x61 0x62 0x63 0x00 0x7f 0x7f 0x7f 0x7f

dst <span class="token operator">=</span> 0x61 0x62 0x63 0x00 0x00 0x00 0x00 0x00</code></pre>
        </main>
        <footer>
            <span>
                <a href="mailto:david.bouchet.epita@gmail.com">David Bouchet</a>
            </span>
        </footer>
    
</body></html>